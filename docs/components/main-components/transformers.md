---
sidebar_position: 7
title: Transformers
tags:
  - component
  - main-component
  - transformer
  - controller
  - response
  - model
---

Transformers,
often referred to as Response Transformers, serve a similar purpose to Views, but specifically for JSON responses.
While Views are responsible for presenting data in HTML format,
Transformers take data and format it into JSON representation.

For more detailed information about transformers and their usage,
you can refer to the [official documentation of Fractal](https://fractal.thephpleague.com/transformers/),
which is the underlying library used for handling transformations in Apiato.

To generate new transformers
you may use the `apiato:generate:transformer` interactive command:

```
php artisan apiato:generate:transformer
```

## Definition & Principles

Read [**Porto SAP Documentation (#Transformers)**](https://github.com/Mahmoudz/Porto#definitions--principles).

## Rules

- All Transformers:
  - MUST be placed in the `app/Containers/{Section}/{Container}/UI/API/Transformers` directory.
  - MUST extend the `App\Ship\Parents\Transformers\Transformer` class.
    - The parent extension SHOULD be aliased as `ParentTransformer`.
  - MUST have a public `transform` method returning an array.

## Folder Structure

```markdown
app
└── Containers
    └── Section
        └── Container
            └── UI
                └── API
                    └── Transformers
                        ├── TransformerA.php
                        ├── TransformerB.php
                        └── ...
```

## Code Example

```php
use ...
use App\Ship\Parents\Transformers\Transformer as ParentTransformer;

class UserTransformer extends ParentTransformer
{
    protected $availableIncludes = [];

    protected $defaultIncludes = [];

    public function transform(User $user)
    {
        return [
            'object' => $user->getResourceKey(),
            'id' => $user->getHashedKey(),
            'name' => $user->name,
            // ...
        ];
    }
}
```

## Model Relationships

Model relationships can be included in the response either per API consumer request or by default.

To include relationships in the response,
the Transformer must have the `availableIncludes` or `defaultIncludes` property defined,
and the `include{RelationshipName}` method implemented.
The method name MUST be in PascalCase format
and match the relationship name as defined in the `availableIncludes` or `defaultIncludes` property.
Additionally, the method name MUST be prefixed with the word `include`.

```php
protected $availableIncludes = [
    'categoryItem',
];

public function includeCategoryItem(Model $model)
{
    // Implementation of including the 'categoryItem' relationship in the response
    // ...
}
```

### Include Per API Consumer Request

To include a relationship in the response,
you must first define the relationship in the `availableIncludes` property of the transformer.

In this example, the `UserTransformer` has the `roles` and `avatar` relationships defined as available includes.

To request the `Roles` data along with the `User` resource,
pass the `?include=roles` query parameter with the API request.

To request multiple relationship includes at once, use the comma separator, for example: `?include=roles,avatar`.

```php
protected $availableIncludes = [
    'roles',
    'avatar',
];

public function includeRoles(User $user): Collection
{
    return $this->collection($user->roles, new RoleTransformer());
}

public function includeAvatar(User $user): Item
{
    return $this->item($user->avatar, new ImageTransformer());
}
```
If the relationship is a collection, the `include{RelationshipName}` method should return a `Collection` object.
If the relationship is a single model, the `include{RelationshipName}` method should return an `Item` object.
You can use the `collection` and `item` methods to create the corresponding Fractal objects.

By defining the `availableIncludes` and implementing the corresponding `include{RelationshipName}` methods,
the API consumers can control which related data they want to include in the response,
improving the flexibility and efficiency of your API.

### Include By Default

To automatically include a relationship in every response from the transformer,
you can define the relationship directly in the transformer's `defaultIncludes` property.
In this example, the `UserTransformer` has the `avatar` relationship defined as a default include.

By setting default includes,
the specified relationships will be automatically included in every response generated by this transformer,
without the need for API consumers to explicitly request them.
This can help simplify responses and reduce the number of additional API requests for related data,
improving the overall efficiency of the API.

```php
protected $defaultIncludes = [
    'avatar',
];

public function includeAvatar(User $user): Item
{
    return $this->item($user->avatar, new ImageTransformer());
}
```

## Resource Key

The transformer allows appending a resource key to the transformed resource.
This is useful when you want to have a consistent response payload format for all your resources.

### Setting the Resource Key

You can set the resource key in your response payload in two ways:

#### Via Model

Specify the resource key on the respective model by setting the `resourceKey` property:

```php
class User extends ParentUserModel
{
    protected $resourceKey = 'User';
}
```

#### Via Controller

Manually set the resource key using the `resourceKey` parameter in the controller's `transform` method:

```php
$this->transform($model, ModelTransformer::class, resourceKey: 'User');
```

:::note
It's important to note that setting the `resourceKey` using the `transform` method will only impact the `top level` resource key
and will not affect the resource keys of `included` resources.
:::

### Getting the Resource Key

Retrieve the resource key from the model by calling the `getResourceKey` method.

If no `resourceKey` is defined on the model, the `getResourceKey` method will return the short class name of the model.
For instance, if no resource key is defined for `App\Containers\AppSection\User\Models\User::class`,
the default resource key will be `User`.

#### Transformer Example
```php
class UserTransformer extends ParentTransformer
{
    // ...
    public function transform(User $user)
    {
        return [
            'object' => $user->getResourceKey(), // <-- here
            'id' => $user->getHashedKey(),
            'name' => $user->name,
            // ...
        ];
    }
    // ...
}
```

#### Response Example
```json
{
  "data": {
    "object": "User", // <-- ResourceKey
    "id": "XbPW7awNkzl83LD6",
    "name": "Mohammad Alavi"
  }
}
```

## Helper Methods

### ifAdmin

The `ifAdmin` method is used
to merge the normal client response with additional or modified results intended for admin users.

```php
public function transform(Model $model)
{
    $response = [
        'object' => $model->getResourceKey(),
        'id' => $model->getHashedKey(),
        'another_field' => $model->anotherField,
    ];

    return $this->ifAdmin([
        'real_id' => $model->id,
        'created_at' => $model->created_at,
        'updated_at' => $model->updated_at,
        'readable_created_at' => $model->created_at->diffForHumans(),
        'readable_updated_at' => $model->updated_at->diffForHumans(),
    ], $response);
}
```

### nullableItem

The `nullableItem` method returns an item if the model has a specific relationship, otherwise, it returns `null`.

```php
use League\Fractal\Resource\Item;
use League\Fractal\Resource\Primitive;

public function includeRelation(Model $model): Primitive|Item
{
    return $this->nullableItem($model->relation, new RelationTransformer();
}
```

If `$model->relation` is not null (meaning it has a related model),
the method returns an item formatted using the specified transformer.
Otherwise, it returns `null`.

The `nullableItem` method is a shortcut for the following code:

```php
use League\Fractal\Resource\Item;
use League\Fractal\Resource\Primitive;

public function includeRelation(Model $model): Primitive|Item
{
    return $model->relation ? $this->item($model->relation, new RelationTransformer()) : $this->primitive(null)
}
```

## Response Payload

You have the flexibility to define your own custom response payload or utilize one of the supported serializers.
Serializer classes let you switch between various output formats with minimal effect on your Transformers.

Current [supported serializers](https://fractal.thephpleague.com/serializers/):
- `ArraySerializer`
- `DataArraySerializer`
- `JsonApiSerializer`

To modify the default Fractal serializer,
access the `app/Ship/Configs/fractal.php` configuration file
and update the `default_serializer` setting to your preferred serializer.

By default, Apiato uses `DataArraySerializer`.
This serializer is not to everyone’s tastes, because it adds a `data` namespace to the output.
A very basic response of the `DataArraySerializer` will look like this:

```json
{
  "data": {
    "object": "User",
    "id": "XbPW7awNkzl83LD6",
    "name": "Mohammad Alavi"
  }
}
```

The `DataArraySerializer` is handy because it allows space for `meta` data
(like pagination, or totals) in both Items and Collections.

```json
{
  "data": [ ... ],
  "meta": {
    "include": [
      "xxx",
      "yyy"
    ],
    "custom": [],
    "pagination": {
      "total": 999,
      "count": 999,
      "per_page": 999,
      "current_page": 999,
      "total_pages": 999,
      "links": {
        "next": "https://api.apiato.test/v1/accounts?page=999"
      }
    }
  }
}
```

:::info Further Reading
For more detailed information, please refer to [Fractal](https://fractal.thephpleague.com/transformers/) and [Laravel Fractal Wrapper](https://github.com/spatie/laravel-fractal) documentations.
:::
