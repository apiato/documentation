---
title: Testing
---

Apiato is built with testing in mind.
In fact,
support for testing with PHPUnit is included out of the box
and a `phpunit.xml` file is already set up for your application.
In addition to the testing capabilities provided by Laravel,
Apiato enhances the testing experience by including convenient helper methods.
These methods enable you to write expressive tests for your applications, further enhancing the testing process.
You can refer to Laravel's documentation on [HTTP tests](https://laravel.com/docs/http-tests) for more information on the available testing methods.

Apiato looks for Unit and Functional tests in [multiple locations](components/optional-components/tests.md).

**Unit tests** are tests that focus on a very small, isolated portion of your code.
In fact, most unit tests probably focus on a single method.

**Functional tests** may test a larger portion of your code,
including how several objects interact with each other or even a full HTTP request to a JSON endpoint.
Generally, most of your tests should be functional tests.
These types of tests provide the most confidence that your system as a whole is functioning as intended.

## Functional Test Helpers {#functional-test-helpers}

<table>
  <thead>
    <tr>
      <th>Method</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>makeCall(array $data = [], array $headers = [])</code>
      </td>
      <td>
        <p>Make an HTTP call to the API.</p>
        <p>It will automatically add the <code>Authorization</code> header if the <code>$auth</code> property is set to <code>true</code>.</p>
        <p>It will automatically add the <code>Accept</code> header if the <code>$accept</code> property is set to <code>json</code>.</p>
      </td>
    </tr>
  </tbody>
</table>

### Properties {#properties}
Some test helper methods read your test class properties, to perform their jobs. Below, we will see those properties
and which method them:

#### $endpoint {#endpoint}

The `$endpoint = 'verb@uri';` property is where you define the endpoints you are trying to access when calling
`$this->makeCall()`.

```php
class RegisterUserTest extends ApiTestCase
{
    protected string $endpoint = 'patch@v1/users/{id}';
    protected bool $auth = false;
    protected array $access = [
        'roles'       => '',
        'permissions' => '',
    ];

    public function testUpdateExistingUser()
    {
        // prepare your post data
        $user = $this->getTestingUser([
            'name' => 'He who should not be named',
            'gender' => 'female',
        ]);
        $data = [
            'name' => 'Updated Name',
            'gender' => 'male',
            'birth' => '2015-10-15',
        ];

        // send the HTTP request
        $response = $this->injectId($user->id)->makeCall($data);

        // assert response status is correct
        $response->assertOk();
    }
}
```

Override the `endpoint` property value in some test methods:
```php
$this->endpoint('get@myEndpoint')->makeCall();
```
Inject the id in the endpoint:
```php
$this->injectId($user->id)->makeCall();
```
#### $auth {#auth}

The `$auth = false;` property determines whether the endpoint being called requires authentication or not.
By default, `$auth` is set to true, and if not explicitly defined in your test class, it will be defaulted to true.

When `$auth` is true,
the `makeCall()` function will automatically create a testing user if one is not already available.
It will then inject the generated access token into the headers before making the API call.

It's important to note that you should only use the `$auth = false;`
property when testing endpoints that do not require authentication, such as register and login tests.
For protected endpoints, authentication is necessary,
and the testing user with the associated access token will be automatically used during the API call.

Override the `auth` property value in some test methods:
```php
$response = $this->auth(false)->makeCall();
```
#### $access {#access}

The `$access` property allows you
to define roles or the permissions that you want to assign to your testing users within a test class.
When you use `$user = $this->getTestingUser();`,
the testing user instance will automatically inherit all the roles and permissions specified in the `$access` property.

By defining the desired roles and permissions in the `$access` property,
you can easily configure the testing user with the necessary access rights for your test scenarios.
This ensures that the testing user has the appropriate privileges when interacting with the application during testing.

```php
protected $access = [
    'roles'         => 'admin', // or   ['client', 'admin']
    'permissions'   => 'delete-users',
];
```

Override the `access` property value in some test methods

```php
// pass the roles and permissions as the second argument.
$this->getTestingUser(null, ['permissions' => 'jump', 'roles' => 'jumper']);
```

### Methods {#methods}

#### makeCall {#make-call}

`makeCall(array $data = [], array $headers = [])` is one of the most important helper methods for an API.

```php
$response = $this->makeCall();

$response = $this->makeCall([
    'email'    => $userDetails['email'],
    'password' => $userDetails['password'],
]);

$response = $this->makeCall($data, $headers);

$response = $this->endpoint('get@register')->makeCall($data);

$response = $this->auth(false)->makeCall();

$response = $this->endpoint('get@item/{id}')->injectId($user->id)->makeCall();
```

#### getTestingUser {#get-testing-user}

The `getTestingUser($userDetails = null, $access = null)` helper function is a valuable tool for obtaining a testing user instance.

Here is how you can use it:

```php
$user = $this->getTestingUser();

$user = $this->getTestingUser([
    'email'    => 'hello@mail.test',
    'name'     => 'Hello',
    'password' => 'secret',
]);
```

By calling `getTestingUser()`, you will receive a testing user instance with random default attributes.
However, you can also provide an array of custom user details as an argument to override those attributes.
In the second example above, a testing user with a specific email, name, and password is generated.

#### getTestingUserWithoutAccess {#get-testing-user-without-access}

Or you can call `getTestingUserWithoutAccess()` to get user without permissions and roles.

#### injectId {#inject-id}

## Available Assertions {#available-assertions}

## Faker {#faker}

An instance of [Faker](https://github.com/FakerPHP/Faker) is automatically provided in every test class, allowing you to generate fake data easily.
You can access it using `$this->faker`.

:::caution Deprecation warning
This feature is deprecated and will be removed in the next major release. You should use the `fake()` helper function instead.
:::

## Create Live Testing Data {#create-live-testing-data}

To test your application using live testing data,
such as creating items in an inventory, you can utilize the feature designed specifically for this purpose.
It allows for the automatic generation of testing data,
which can be helpful during staging or when real people are testing your application.

To create your live testing data, navigate to the `app/Ship/Seeder/SeedTestingData.php` seeder class.
Within this class, you can define the logic and data generation process for your testing data.

Once you have defined your testing data,
you can run the following command in your terminal:

```
php artisan apiato:seed-test
```

This command triggers the seeding process specifically for testing data,
populating your application with the generated data.
